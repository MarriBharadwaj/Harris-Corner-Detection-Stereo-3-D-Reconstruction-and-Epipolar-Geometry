# -*- coding: utf-8 -*-
"""B21CS045_qu1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17XjSJ8stMap-QAuTGXLf3OoO1ClOUjQJ

mounting my google drive
"""

from google.colab import drive
drive.mount('/content/drive')

from PIL import Image

import os
folder_path = os.path.join("/content/drive/MyDrive", "CV_Assgn1_Q1")

image_files = os.listdir(folder_path)
images = []

for file in image_files:
    if file.endswith('.jpg') or file.endswith('.jpeg') or file.endswith('.png'):
        img_path = os.path.join(folder_path, file)
        img = Image.open(img_path)
        images.append(img)
import matplotlib.pyplot as plt

"""Displaying the Images"""

plt.imshow(images[0])
plt.axis('off')
plt.show()

plt.imshow(images[1])
plt.axis('off')
plt.show()

plt.imshow(images[2])
plt.axis('off')
plt.show()

plt.imshow(images[3])
plt.axis('off')
plt.show()

plt.imshow(images[4])
plt.axis('off')
plt.show()

plt.imshow(images[5])
plt.axis('off')
plt.show()

plt.imshow(images[6])
plt.axis('off')
plt.show()

!pip install opencv-python
!pip install pillow
!pip install matplotlib

"""Building the Harris Corner detection algorithm from scratch"""

#importing libraries
import cv2
import os
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
from google.colab import drive
#to represent image in matrix form
def Imagematrixreprsentation(greyscale_image):
  dimensions = greyscale_image.shape
  height = dimensions[0]
  width = dimensions[1]
  image_matrix=[]
  for i in range (0, height):
    row=[]
    for j in range (0,width):
      pxl=greyscale_image.item(i,j)
      row.append(pxl)
    image_matrix.append(row)
  image_matrix = np.array(image_matrix)
#to calculate the convolution matrix
def convolve2d(image, kernel):
    kernel = np.flipud(np.fliplr(kernel))
    output = np.zeros_like(image, dtype=np.float64)
    padding=kernel.shape[0]//2
    for x in range(padding,image.shape[0]-padding):
        for y in range(padding,image.shape[1]-padding):
            output[x, y]=np.sum(image[x-padding:x+padding+1, y-padding:y+padding+1]*kernel)
    return output
#handmade code for harris corner detection implemented from scratch
def harriscornerdetection(img, k):
    cv2_imshow(img)
    greyscale_image=cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    cv2_imshow(greyscale_image)
    dimensions = img.shape
    height = dimensions[0]
    width = dimensions[1]
    print("Image Dimension : {} x {} pixels ".format(width, height))
    print("Image Dimension : {}".format(dimensions))

    Imagematrixreprsentation(greyscale_image)

    sobel_x = np.array([[1, 0, -1],
                            [2, 0, -2],
                            [1, 0, -1]], dtype=np.float64)

    sobel_y = np.array([[1, 2, 1],
                            [0, 0, 0],
                            [-1, -2, -1]], dtype=np.float64)

    grad_x = convolve2d(greyscale_image, sobel_x)
    grad_y = convolve2d(greyscale_image, sobel_y)
    cv2_imshow(grad_x)
    cv2_imshow(grad_y)
    Ixx = grad_x * grad_x
    Ixy = grad_x * grad_y
    Iyy = grad_y * grad_y

    window_filter = np.array([[1, 2, 1],
                              [2, 4, 2],
                              [1, 2, 1]]) / 16

    Ixx_filtered = convolve2d(Ixx, window_filter)
    Ixy_filtered = convolve2d(Ixy, window_filter)
    Iyy_filtered = convolve2d(Iyy, window_filter)
    structure_tensor = np.array([[Ixx_filtered, Ixy_filtered],
                                  [Ixy_filtered, Iyy_filtered]])
    print("Shape of the structure tensor array M :", structure_tensor.shape)


    det_M = (Ixx_filtered * Iyy_filtered) - (Ixy_filtered ** 2)
    trace_M = Ixx_filtered + Iyy_filtered
    R = det_M - k * (trace_M ** 2)
    threshold=0.1*R.max()
    R_suppressed = np.zeros_like(R)
    offset = 3 // 2
    for i in range(offset, R.shape[0] - offset):
            for j in range(offset, R.shape[1] - offset):
                window = R[i - offset: i + offset + 1, j - offset: j + offset + 1]
                if R[i, j] == np.max(window) and R[i, j] > threshold:
                    R_suppressed[i, j] = R[i, j]
    corners=np.argwhere(R_suppressed != 0)
    image=greyscale_image.copy()
    plt.figure(figsize=(8, 8))
    plt.imshow(image, cmap='gray')
    plt.plot(corners[:, 1], corners[:, 0], 'r.', markersize=5)
    plt.axis('off')
    plt.title(f'Detected corners')
    plt.show()

    return corners
#inbuilt corner detection from OpenCV library from comparison
def HarrisDetectionOpenCv(img, k):
    gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    dest = cv2.cornerHarris(gray_img, 3, 3, k)
    dest = cv2.dilate(dest, None)
    img=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img[dest > 0.1 * dest.max()] = [0, 0, 255]
    return img

"""(here partition refers to "||||" to divide the tasks)

Pre-partition:

              I have applied both my harris corner detection algoirithm and the inbuilt algorithm on the input images and stored them in respective variables for later visual comparison. The displayed images and detection here are of my handmade algorithm. I have greyscaled the images to reduce noise and improve efficiency


Post-partition:

              I have now displayed the stored results of both the algorithms for visual inspection and evalutation
"""

images=[]
corners=[]
opencv_output=[]
i = 0
for image_name in os.listdir(folder_path):
        img = cv2.imread(os.path.join(folder_path, image_name))
        if img is not None:
            print(f"Calculating for Image- {i}")
            i = i + 1
            resultant_corners=harriscornerdetection(img, 0.04)
            corners.append(resultant_corners)
            resultant_opencv_image=HarrisDetectionOpenCv(img, 0.04)
            opencv_output.append(resultant_opencv_image)
            images.append(img)
            print("------------------------------------------------------------------")
print("|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||")
print("|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||")
print("|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||")
#plotting corners
def plot_corners(image, corners, title, cv):
    plt.imshow(image)
    if(cv == 0):
       plt.plot(corners[:, 1], corners[:, 0], 'r.', markersize=5)
    plt.axis('off')
    plt.title(title)
    plt.show()
#displaying them
for i in range(len(images)):
    if len(images[i].shape) == 3 and images[i].shape[2] == 3:
        images[i] = cv2.cvtColor(images[i], cv2.COLOR_BGR2RGB)
    plot_corners(images[i],corners[i],f'Output of handmade Harris Corner detection implemented from scratch for Image-{i}', 0)
    plot_corners(opencv_output[i],corners[i],f'Output of inbuiltOpenCV Harris Corner detection for Image-{i}', 1)
    print("------------------------------------------------------------------")